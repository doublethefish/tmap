%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}





\title{TMAP}
\date{Jul 03, 2019}
\release{0.2.0}
\author{}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Table of Contents}
\label{\detokenize{index:table-of-contents}}

\section{Getting Started}
\label{\detokenize{tutorial:getting-started}}\label{\detokenize{tutorial::doc}}

\subsection{Installation}
\label{\detokenize{tutorial:installation}}
TMAP can be installed using the conda package manager that
is distributed with miniconda (or anaconda).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda install tmap
\end{sphinxVerbatim}

The module is then best imported using a shorter identifier.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tmap} \PYG{k+kn}{as} \PYG{n+nn}{tm}
\end{sphinxVerbatim}


\subsection{Laying out a Simple Graph}
\label{\detokenize{tutorial:laying-out-a-simple-graph}}
Even though TMAP is mainly targeted at tasks consisting of
laying out very large data sets, the simplest usage example
is laying out a graph.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tmap} \PYG{k+kn}{as} \PYG{n+nn}{tm}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}

\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{25}
\PYG{n}{edge\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Create a random graph}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{high}\PYG{o}{=}\PYG{n}{n}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{edge\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set the initial randomized positioning to True}
\PYG{c+c1}{\PYGZsh{} Otherwise, OGDF tends to segfault}
\PYG{n}{cfg} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{LayoutConfiguration}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cfg}\PYG{o}{.}\PYG{n}{fme\PYGZus{}randomize} \PYG{o}{=} \PYG{n+nb+bp}{True}

\PYG{c+c1}{\PYGZsh{} Compute the layout}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{gp} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{layout\PYGZus{}from\PYGZus{}edge\PYGZus{}list}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{edge\PYGZus{}list}\PYG{p}{,} \PYG{n}{config}\PYG{o}{=}\PYG{n}{cfg}\PYG{p}{,}
                                          \PYG{n}{create\PYGZus{}mst}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the edges}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{y}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the vertices}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{simple\PYGZus{}graph.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{simple_graph}.png}

When laying out large graphs, it might be useful to discard
some edges in order to create a more interpretable and visually
pleasing layout. This is achieved using the (default) argument
\sphinxcode{\sphinxupquote{create\_mst=True}}. Following, this is exemplified on a small
graph.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{edge\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{weights} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} Create a random graph}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{high}\PYG{o}{=}\PYG{n}{n}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Do not add parallel edges here, to be sure}
        \PYG{c+c1}{\PYGZsh{} to have the right weight later}
        \PYG{k}{if} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{weights} \PYG{o+ow}{and} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{weights}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o+ow}{or} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{weights} \PYG{o+ow}{and} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{weights}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{continue}

        \PYG{n}{weight} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{edge\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{weight}\PYG{p}{]}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Store the weights in 2d map for easy access}
        \PYG{k}{if} \PYG{n}{i} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{weights}\PYG{p}{:}
            \PYG{n}{weights}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{n}{j} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{weights}\PYG{p}{:}
            \PYG{n}{weights}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{\PYGZsh{} Invert weights to make lower ones more visible in the plot}
        \PYG{n}{weights}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{weight}
        \PYG{n}{weights}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{weight}


\PYG{c+c1}{\PYGZsh{} Set the initial randomized positioning to True}
\PYG{c+c1}{\PYGZsh{} Otherwise, OGDF tends to segfault}
\PYG{n}{cfg} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{LayoutConfiguration}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cfg}\PYG{o}{.}\PYG{n}{fme\PYGZus{}randomize} \PYG{o}{=} \PYG{n+nb+bp}{True}

\PYG{c+c1}{\PYGZsh{} Compute the layout}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{layout\PYGZus{}from\PYGZus{}edge\PYGZus{}list}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{edge\PYGZus{}list}\PYG{p}{,} \PYG{n}{config}\PYG{o}{=}\PYG{n}{cfg}\PYG{p}{,}
                                         \PYG{n}{create\PYGZus{}mst}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{n}{x\PYGZus{}mst}\PYG{p}{,} \PYG{n}{y\PYGZus{}mst}\PYG{p}{,} \PYG{n}{s\PYGZus{}mst}\PYG{p}{,} \PYG{n}{t\PYGZus{}mst}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{layout\PYGZus{}from\PYGZus{}edge\PYGZus{}list}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{edge\PYGZus{}list}\PYG{p}{,}
                                                         \PYG{n}{create\PYGZus{}mst}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ax1}\PYG{p}{,} \PYG{n}{ax2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{ncols}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{sharey}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot graph layout with spanning tree superimposed in red}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ax1}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{y}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{n}{linewidth}\PYG{o}{=}\PYG{n}{weights}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s\PYGZus{}mst}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ax1}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{n}{s\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{n}{t\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{y}\PYG{p}{[}\PYG{n}{s\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{t\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{n}{linewidth}\PYG{o}{=}\PYG{n}{weights}\PYG{p}{[}\PYG{n}{s\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{t\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Plot spanning tree layout}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s\PYGZus{}mst}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ax2}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x\PYGZus{}mst}\PYG{p}{[}\PYG{n}{s\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x\PYGZus{}mst}\PYG{p}{[}\PYG{n}{t\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{y\PYGZus{}mst}\PYG{p}{[}\PYG{n}{s\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}mst}\PYG{p}{[}\PYG{n}{t\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{n}{linewidth}\PYG{o}{=}\PYG{n}{weights}\PYG{p}{[}\PYG{n}{s\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{t\PYGZus{}mst}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x\PYGZus{}mst}\PYG{p}{,} \PYG{n}{y\PYGZus{}mst}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spanning\PYGZus{}tree.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{spanning_tree}.png}

On a highly connected graph with 1000 vertices, the advantages
of the tree visualizaton method applied by TMAP become obvious.

\noindent\sphinxincludegraphics{{spanning_tree_big}.png}

There are a wide array of options to tune the final tree layout
to your linking. See {\hyperref[\detokenize{documentation:layout-doc}]{\sphinxcrossref{\DUrole{std,std-ref}{Layout}}}} for the descriptions of all
available parameters.


\subsection{MinHash}
\label{\detokenize{tutorial:minhash}}
In order to enable the visualization of larger data sets, it is
necessary to speed up the k-nearest neighbor graph generation. While
in general, any approach can be used to create this nearest neighbor
graph (see Laying out a Simple Graph), TMAP provides a built-in LSH Forest
data structure, which enables extremely fast k-nearest neighbor queries.

In order to index data in the LSH forest data structure, it has to be
hashed using a locality sensitive scheme such as MinHash.

TMAP includes the two classes \sphinxcode{\sphinxupquote{MinHash}} and \sphinxcode{\sphinxupquote{LSHForest}} for
fast k-nearest neighbor search.

The following example shows how to use the \sphinxcode{\sphinxupquote{MinHash}} class to estimate
Jaccard distances.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tmap} \PYG{k+kn}{as} \PYG{n+nn}{tm}

\PYG{n}{enc} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{Minhash}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{mh\PYGZus{}a} \PYG{o}{=} \PYG{n}{enc}\PYG{o}{.}\PYG{n}{from\PYGZus{}binary\PYGZus{}array}\PYG{p}{(}\PYG{n}{tm}\PYG{o}{.}\PYG{n}{VectorUchar}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{mh\PYGZus{}b} \PYG{o}{=} \PYG{n}{enc}\PYG{o}{.}\PYG{n}{from\PYGZus{}binary\PYGZus{}array}\PYG{p}{(}\PYG{n}{tm}\PYG{o}{.}\PYG{n}{VectorUchar}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{mh\PYGZus{}c} \PYG{o}{=} \PYG{n}{enc}\PYG{o}{.}\PYG{n}{from\PYGZus{}binary\PYGZus{}array}\PYG{p}{(}\PYG{n}{tm}\PYG{o}{.}\PYG{n}{VectorUchar}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{dist\PYGZus{}a\PYGZus{}b} \PYG{o}{=} \PYG{n}{enc}\PYG{o}{.}\PYG{n}{get\PYGZus{}distance}\PYG{p}{(}\PYG{n}{mh\PYGZus{}a}\PYG{p}{,} \PYG{n}{mh\PYGZus{}b}\PYG{p}{)}
\PYG{n}{dist\PYGZus{}b\PYGZus{}c} \PYG{o}{=} \PYG{n}{enc}\PYG{o}{.}\PYG{n}{get\PYGZus{}distance}\PYG{p}{(}\PYG{n}{mh\PYGZus{}b}\PYG{p}{,} \PYG{n}{mh\PYGZus{}c}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{dist\PYGZus{}a\PYGZus{}b}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{dist\PYGZus{}b\PYGZus{}c}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{0.390625}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{0.140625}
\end{sphinxVerbatim}

An in-depth explanation of MinHash can be found in
\sphinxhref{https://www.youtube.com/watch?v=96WOGPUgMfw}{this} video by Jeffry D
Ullman.

\sphinxcode{\sphinxupquote{Minhash}} also supports encoding strings, indexed binary arrays, and
\sphinxcode{\sphinxupquote{int}} and \sphinxcode{\sphinxupquote{float}} weighted arrays. See {\hyperref[\detokenize{documentation:minhash-doc}]{\sphinxcrossref{\DUrole{std,std-ref}{MinHash}}}} for details.


\subsection{LSH Forest}
\label{\detokenize{tutorial:lsh-forest}}
The hashes generated by \sphinxcode{\sphinxupquote{Minhash}} can be indexed using \sphinxcode{\sphinxupquote{LSHForest}}
for fast k-nearest neighbor retreival.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{timeit} \PYG{k+kn}{import} \PYG{n}{default\PYGZus{}timer} \PYG{k}{as} \PYG{n}{timer}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{tmap} \PYG{k+kn}{as} \PYG{n+nn}{tm}

\PYG{c+c1}{\PYGZsh{} Use 128 permutations to create the MinHash}
\PYG{n}{enc} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{Minhash}\PYG{p}{(}\PYG{l+m+mi}{128}\PYG{p}{)}
\PYG{n}{lf} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{LSHForest}\PYG{p}{(}\PYG{l+m+mi}{128}\PYG{p}{)}

\PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{1000000}

\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Generating some random data}
\PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tm}\PYG{o}{.}\PYG{n}{VectorUchar}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{high}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Generating the data took \PYGZob{}(timer() \PYGZhy{} start) * 1000\PYGZcb{}ms.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Use batch\PYGZus{}add to parallelize the insertion of the arrays}
\PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{lf}\PYG{o}{.}\PYG{n}{batch\PYGZus{}add}\PYG{p}{(}\PYG{n}{enc}\PYG{o}{.}\PYG{n}{batch\PYGZus{}from\PYGZus{}binary\PYGZus{}array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Adding the data took \PYGZob{}(timer() \PYGZhy{} start) * 1000\PYGZcb{}ms.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Index the added data}
\PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{lf}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Indexing took \PYGZob{}(timer() \PYGZhy{} start) * 1000\PYGZcb{}ms.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Find the 10 nearest neighbors of the first entry}
\PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{lf}\PYG{o}{.}\PYG{n}{query\PYGZus{}linear\PYGZus{}scan\PYGZus{}by\PYGZus{}id}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The kNN search took \PYGZob{}(timer() \PYGZhy{} start) * 1000\PYGZcb{}ms.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Generating} \PYG{n}{the} \PYG{n}{data} \PYG{n}{took} \PYG{l+m+mf}{118498.04133399994}\PYG{n}{ms}\PYG{o}{.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Adding} \PYG{n}{the} \PYG{n}{data} \PYG{n}{took} \PYG{l+m+mf}{55051.067827000224}\PYG{n}{ms}\PYG{o}{.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Indexing} \PYG{n}{took} \PYG{l+m+mf}{2059.1810410005564}\PYG{n}{ms}\PYG{o}{.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{The} \PYG{n}{kNN} \PYG{n}{search} \PYG{n}{took} \PYG{l+m+mf}{0.32151699997484684}\PYG{n}{ms}\PYG{o}{.}
\end{sphinxVerbatim}

After indexing the data, the 10 nearest neighbor search on a million
1,000-dimensional vectors took \textasciitilde{}0.32ms. In addition, the \sphinxcode{\sphinxupquote{LSHForest}}
class also supports the parallelized generation of a k-nearest neighbor graph
using the method \sphinxcode{\sphinxupquote{get\_knn\_graph()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} ...}

\PYG{c+c1}{\PYGZsh{} Construct the k\PYGZhy{}nearest neighbour graph}
\PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{knng\PYGZus{}from} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{VectorUint}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{knng\PYGZus{}to} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{VectorUint}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{knng\PYGZus{}weight} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{VectorFloat}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{result} \PYG{o}{=} \PYG{n}{lf}\PYG{o}{.}\PYG{n}{get\PYGZus{}knn\PYGZus{}graph}\PYG{p}{(}\PYG{n}{knng\PYGZus{}from}\PYG{p}{,} \PYG{n}{knng\PYGZus{}to}\PYG{p}{,} \PYG{n}{knng\PYGZus{}weight}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The kNN search took \PYGZob{}(timer() \PYGZhy{} start) * 1000\PYGZcb{}ms.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{The} \PYG{n}{kNN} \PYG{n}{search} \PYG{n}{took} \PYG{l+m+mf}{37519.07863999986}\PYG{n}{ms}\PYG{o}{.}
\end{sphinxVerbatim}


\subsection{Layout}
\label{\detokenize{tutorial:layout}}
TMAP ships with the function \sphinxcode{\sphinxupquote{layout\_from\_lsh\_forest()}} which
creates a graph / tree layout directly from an \sphinxcode{\sphinxupquote{LSHForest}} instance.

The resulting layout can then be plotted using matplotlib / pyplot using
its \sphinxcode{\sphinxupquote{plot()}} and \sphinxcode{\sphinxupquote{scatter}} methods.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} ...}

\PYG{c+c1}{\PYGZsh{} The configuration for the MST plot}
\PYG{c+c1}{\PYGZsh{} Distribute the tree more evenly}
\PYG{n}{cfg} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{LayoutConfiguration}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cfg}\PYG{o}{.}\PYG{n}{sl\PYGZus{}scaling\PYGZus{}min} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{cfg}\PYG{o}{.}\PYG{n}{sl\PYGZus{}scaling\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{cfg}\PYG{o}{.}\PYG{n}{node\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{50}

\PYG{c+c1}{\PYGZsh{} Construct the k\PYGZhy{}nearest neighbour graph}
\PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{tm}\PYG{o}{.}\PYG{n}{layout\PYGZus{}from\PYGZus{}lsh\PYGZus{}forest}\PYG{p}{(}\PYG{n}{lf}\PYG{p}{,} \PYG{n}{config}\PYG{o}{=}\PYG{n}{cfg}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{layout\PYGZus{}from\PYGZus{}lsh\PYGZus{}forest took \PYGZob{}(timer() \PYGZhy{} start) * 1000\PYGZcb{}ms.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot spanning tree layout}
\PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{y}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lsh\PYGZus{}forest\PYGZus{}knng\PYGZus{}mpl.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Plotting using matplotlib took \PYGZob{}(timer() \PYGZhy{} start) * 1000\PYGZcb{}ms.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{layout\PYGZus{}from\PYGZus{}lsh\PYGZus{}forest} \PYG{n}{took} \PYG{l+m+mf}{1218.4765429992694}\PYG{n}{ms}\PYG{o}{.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Plotting} \PYG{n}{using} \PYG{n}{matplotlib} \PYG{n}{took} \PYG{l+m+mf}{35739.334431000316}\PYG{n}{ms}\PYG{o}{.}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{lsh_forest_knng_mpl}.png}

Using matplotlib / pyplot has tow main disadvantages: It is slow and does
not yield interactive plots. For this reason, we suggest to use
the Python package \sphinxhref{https://pypi.org/project/faerun/}{Faerun}
for large scale data sets. Faerun supports millions of data points in web-based
visualizations.

Together with TMAP, Faerun can easily create visualizations of more than
10 million data points including associated web links and structure drawings
for high dimensional chemical data sets within an hour.

\noindent\sphinxincludegraphics{{fdb}.png}

\noindent\sphinxincludegraphics{{fdb_zoom}.png}


\section{Documentation}
\label{\detokenize{documentation:documentation}}\label{\detokenize{documentation::doc}}

\subsection{MinHash}
\label{\detokenize{documentation:minhash}}\label{\detokenize{documentation:minhash-doc}}\index{Minhash (class in tmap)@\spxentry{Minhash}\spxextra{class in tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{Minhash}}}{\emph{self: tmap.Minhash}, \emph{d: int=128}, \emph{seed: int=42}, \emph{sample\_size: int=128}}{{ $\rightarrow$ None}}
A generator for MinHash vectors that supports binary, indexed, string and also \sphinxcode{\sphinxupquote{int}} and \sphinxcode{\sphinxupquote{float}} weighted vectors as input.

Constructor for the class {\hyperref[\detokenize{documentation:tmap.Minhash}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Minhash}}}}}.
\begin{quote}\begin{description}
\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{d}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of permutations used for hashing

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{seed}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The seed used for the random number generator(s)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sample\_size}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The sample size when generating a weighted MinHash

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (tmap.Minhash method)@\spxentry{\_\_init\_\_()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{self: tmap.Minhash}, \emph{d: int=128}, \emph{seed: int=42}, \emph{sample\_size: int=128}}{{ $\rightarrow$ None}}
Constructor for the class {\hyperref[\detokenize{documentation:tmap.Minhash}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Minhash}}}}}.
\begin{quote}\begin{description}
\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{d}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of permutations used for hashing

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{seed}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The seed used for the random number generator(s)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sample\_size}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The sample size when generating a weighted MinHash

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{batch\_from\_binary\_array() (tmap.Minhash method)@\spxentry{batch\_from\_binary\_array()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.batch_from_binary_array}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{batch\_from\_binary\_array}}}{\emph{self: tmap.Minhash, arg0: List{[}tmap.VectorUchar{]}}}{{ $\rightarrow$ List{[}tmap.VectorUint{]}}}
Create MinHash vectors from binary arrays (parallelized).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUchar}}) \textendash{} A list of vectors containing binary values

\item[{Returns}] \leavevmode
A list of MinHash vectors

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{batch\_from\_int\_weight\_array() (tmap.Minhash method)@\spxentry{batch\_from\_int\_weight\_array()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.batch_from_int_weight_array}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{batch\_from\_int\_weight\_array}}}{\emph{self: tmap.Minhash, arg0: List{[}tmap.VectorUint{]}}}{{ $\rightarrow$ List{[}tmap.VectorUint{]}}}
Create MinHash vectors from \sphinxcode{\sphinxupquote{int}} arrays, where entries are weights rather than indices of ones (parallelized).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A list of vectors containing \sphinxcode{\sphinxupquote{int}} values

\item[{Returns}] \leavevmode
A list of MinHash vectors

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{batch\_from\_sparse\_binary\_array() (tmap.Minhash method)@\spxentry{batch\_from\_sparse\_binary\_array()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.batch_from_sparse_binary_array}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{batch\_from\_sparse\_binary\_array}}}{\emph{self: tmap.Minhash, arg0: List{[}tmap.VectorUint{]}}}{{ $\rightarrow$ List{[}tmap.VectorUint{]}}}
Create MinHash vectors from sparse binary arrays (parallelized).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A list of vectors containing indices of ones in a binary array

\item[{Returns}] \leavevmode
A list of MinHash vectors

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{batch\_from\_string\_array() (tmap.Minhash method)@\spxentry{batch\_from\_string\_array()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.batch_from_string_array}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{batch\_from\_string\_array}}}{\emph{self: tmap.Minhash, arg0: List{[}List{[}str{]}{]}}}{{ $\rightarrow$ List{[}tmap.VectorUint{]}}}
Create MinHash vectors from string arrays (parallelized).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{str}}) \textendash{} A list of list of strings

\item[{Returns}] \leavevmode
A list of MinHash vectors

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{batch\_from\_weight\_array() (tmap.Minhash method)@\spxentry{batch\_from\_weight\_array()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.batch_from_weight_array}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{batch\_from\_weight\_array}}}{\emph{self: tmap.Minhash, arg0: List{[}tmap.VectorFloat{]}}}{{ $\rightarrow$ List{[}tmap.VectorUint{]}}}
Create MinHash vectors from \sphinxcode{\sphinxupquote{float}} arrays (parallelized).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorFloat}}) \textendash{} A list of vectors containing \sphinxcode{\sphinxupquote{float}} values

\item[{Returns}] \leavevmode
A list of MinHash vectors

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_binary\_array() (tmap.Minhash method)@\spxentry{from\_binary\_array()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.from_binary_array}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_binary\_array}}}{\emph{self: tmap.Minhash}, \emph{arg0: tmap.VectorUchar}}{{ $\rightarrow$ tmap.VectorUint}}
Create a MinHash vector from a binary array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{VectorUchar}}) \textendash{} A vector containing binary values

\item[{Returns}] \leavevmode
A MinHash vector

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_sparse\_binary\_array() (tmap.Minhash method)@\spxentry{from\_sparse\_binary\_array()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.from_sparse_binary_array}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_sparse\_binary\_array}}}{\emph{self: tmap.Minhash}, \emph{arg0: tmap.VectorUint}}{{ $\rightarrow$ tmap.VectorUint}}
Create a MinHash vector from a sparse binary array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A vector containing indices of ones in a binary array

\item[{Returns}] \leavevmode
A MinHash vector

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_string\_array() (tmap.Minhash method)@\spxentry{from\_string\_array()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.from_string_array}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_string\_array}}}{\emph{self: tmap.Minhash, arg0: List{[}str{]}}}{{ $\rightarrow$ tmap.VectorUint}}
Create a MinHash vector from a string array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{str}}) \textendash{} A vector containing strings

\item[{Returns}] \leavevmode
A MinHash vector

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_weight\_array() (tmap.Minhash method)@\spxentry{from\_weight\_array()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.from_weight_array}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_weight\_array}}}{\emph{self: tmap.Minhash}, \emph{arg0: tmap.VectorFloat}}{{ $\rightarrow$ tmap.VectorUint}}
Create a MinHash vector from a \sphinxcode{\sphinxupquote{float}} array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{VectorFloat}}) \textendash{} A vector containing \sphinxcode{\sphinxupquote{float}} values

\item[{Returns}] \leavevmode
A MinHash vector

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_distance() (tmap.Minhash method)@\spxentry{get\_distance()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.get_distance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_distance}}}{\emph{self: tmap.Minhash}, \emph{arg0: tmap.VectorUint}, \emph{arg1: tmap.VectorUint}}{{ $\rightarrow$ float}}
Calculate the Jaccard distance between two MinHash vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec\_a}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec\_b}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A MinHash vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{float}} The Jaccard distance

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_weighted\_distance() (tmap.Minhash method)@\spxentry{get\_weighted\_distance()}\spxextra{tmap.Minhash method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Minhash.get_weighted_distance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_weighted\_distance}}}{\emph{self: tmap.Minhash}, \emph{arg0: tmap.VectorUint}, \emph{arg1: tmap.VectorUint}}{{ $\rightarrow$ float}}
Calculate the weighted Jaccard distance between two MinHash vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec\_a}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A weighted MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec\_b}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A weighted MinHash vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{float}} The Jaccard distance

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{LSH Forest}
\label{\detokenize{documentation:lsh-forest}}\label{\detokenize{documentation:lshforest-doc}}\index{LSHForest (class in tmap)@\spxentry{LSHForest}\spxextra{class in tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{LSHForest}}}{\emph{self: tmap.LSHForest}, \emph{d: int=128}, \emph{l: int=8}, \emph{store: bool=True}, \emph{file\_backed: bool=False}}{{ $\rightarrow$ None}}
A LSH forest data structure which incorporates optional linear scan to increase the recovery performance. Most query methods are available in parallelized versions named with a \sphinxcode{\sphinxupquote{batch\_}} prefix.

Constructor for the class {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}}.
\begin{quote}\begin{description}
\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{d}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The dimensionality of the MinHashe vectors to be added

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of prefix trees used when indexing data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{store}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_backed}} (\sphinxcode{\sphinxupquote{bool}}) Whether to store the data on disk rather than in main memory (experimental) \textendash{} 

\end{itemize}

\end{description}\end{quote}
\index{\_\_init\_\_() (tmap.LSHForest method)@\spxentry{\_\_init\_\_()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{self: tmap.LSHForest}, \emph{d: int=128}, \emph{l: int=8}, \emph{store: bool=True}, \emph{file\_backed: bool=False}}{{ $\rightarrow$ None}}
Constructor for the class {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}}.
\begin{quote}\begin{description}
\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{d}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The dimensionality of the MinHashe vectors to be added

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of prefix trees used when indexing data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{store}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_backed}} (\sphinxcode{\sphinxupquote{bool}}) Whether to store the data on disk rather than in main memory (experimental) \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add() (tmap.LSHForest method)@\spxentry{add()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.add}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add}}}{\emph{self: tmap.LSHForest}, \emph{arg0: tmap.VectorUint}}{{ $\rightarrow$ None}}
Add a MinHash vector to the LSH forest.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vecs}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A MinHash vector that is to be added to the LSH forest

\end{description}\end{quote}

\end{fulllineitems}

\index{batch\_add() (tmap.LSHForest method)@\spxentry{batch\_add()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.batch_add}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{batch\_add}}}{\emph{self: tmap.LSHForest, arg0: List{[}tmap.VectorUint{]}}}{{ $\rightarrow$ None}}
Add a list MinHash vectors to the LSH forest (parallelized).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vecs}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A list of MinHash vectors that is to be added to the LSH forest

\end{description}\end{quote}

\end{fulllineitems}

\index{batch\_query() (tmap.LSHForest method)@\spxentry{batch\_query()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.batch_query}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{batch\_query}}}{\emph{self: tmap.LSHForest, arg0: List{[}tmap.VectorUint{]}, arg1: int}}{{ $\rightarrow$ List{[}tmap.VectorUint{]}}}
Query the LSH forest for k-nearest neighbors (parallelized).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vecs}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} The query MinHash vectors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\end{itemize}

\item[{Returns}] \leavevmode
The results of the queries

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{clear() (tmap.LSHForest method)@\spxentry{clear()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.clear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{\emph{self: tmap.LSHForest}}{{ $\rightarrow$ None}}
Clears all the added data and computed indices from this {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance.

\end{fulllineitems}

\index{get\_all\_distances() (tmap.LSHForest method)@\spxentry{get\_all\_distances()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.get_all_distances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_all\_distances}}}{\emph{self: tmap.LSHForest}, \emph{arg0: tmap.VectorUint}}{{ $\rightarrow$ tmap.VectorFloat}}
Calculate the Jaccard distances of a MinHash vector to all indexed MinHash vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} The query MinHash vector

\item[{Returns}] \leavevmode
The Jaccard distances

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{float}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_nearest\_neighbors() (tmap.LSHForest method)@\spxentry{get\_all\_nearest\_neighbors()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.get_all_nearest_neighbors}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_all\_nearest\_neighbors}}}{\emph{self: tmap.LSHForest}, \emph{k: int}, \emph{kc: int=10}, \emph{weighted: bool=False}}{{ $\rightarrow$ tmap.VectorUint}}
Get the k-nearest neighbors of all indexed MinHash vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kc}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The factor by which \sphinxcode{\sphinxupquote{k}} is multiplied for LSH forest retreival

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weighted}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} Whether the MinHash vectors in this {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance are weighted

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}} The ids of all k-nearest neighbors

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_distance() (tmap.LSHForest method)@\spxentry{get\_distance()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.get_distance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_distance}}}{\emph{self: tmap.LSHForest}, \emph{arg0: tmap.VectorUint}, \emph{arg1: tmap.VectorUint}}{{ $\rightarrow$ float}}
Calculate the Jaccard distance between two MinHash vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec\_a}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec\_b}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A MinHash vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{float}} The Jaccard distance

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_distance\_by\_id() (tmap.LSHForest method)@\spxentry{get\_distance\_by\_id()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.get_distance_by_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_distance\_by\_id}}}{\emph{self: tmap.LSHForest}, \emph{arg0: int}, \emph{arg1: int}}{{ $\rightarrow$ float}}
Calculate the Jaccard distance between two indexed MinHash vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The id of an indexed MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The id of an indexed MinHash vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{float}} The Jaccard distance

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_hash() (tmap.LSHForest method)@\spxentry{get\_hash()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.get_hash}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_hash}}}{\emph{self: tmap.LSHForest}, \emph{arg0: int}}{{ $\rightarrow$ tmap.VectorUint}}
Retrieve the MinHash vector of an indexed entry given its index. The index is defined by order of insertion.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The id of an indexed MinHash vector

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}} The MinHash vector

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_knn\_graph() (tmap.LSHForest method)@\spxentry{get\_knn\_graph()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.get_knn_graph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_knn\_graph}}}{\emph{self: tmap.LSHForest}, \emph{from: tmap.VectorUint}, \emph{to: tmap.VectorUint}, \emph{weight: tmap.VectorFloat}, \emph{k: int}, \emph{kc: int=10}, \emph{weighted: bool=False}}{{ $\rightarrow$ None}}
Construct the k-nearest neighbor graph of the indexed MinHash vectors. It will be written to out parameters \sphinxcode{\sphinxupquote{from}}, \sphinxcode{\sphinxupquote{to}}, and \sphinxcode{\sphinxupquote{weight}} as an edge list.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{from}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A vector to which the ids for the from vertices are written

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{to}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A vector to which the ids for the to vertices are written

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} (\sphinxcode{\sphinxupquote{VectorFloat}}) \textendash{} A vector to which the edge weights are written

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved during the construction of the k-nearest neighbor graph

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kc}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The factor by which \sphinxcode{\sphinxupquote{k}} is multiplied for LSH forest retreival

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weighted}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} Whether the MinHash vectors in this {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance are weighted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_weighted\_distance() (tmap.LSHForest method)@\spxentry{get\_weighted\_distance()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.get_weighted_distance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_weighted\_distance}}}{\emph{self: tmap.LSHForest}, \emph{arg0: tmap.VectorUint}, \emph{arg1: tmap.VectorUint}}{{ $\rightarrow$ float}}
Calculate the weighted Jaccard distance between two MinHash vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec\_a}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A weighted MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec\_b}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} A weighted MinHash vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{float}} The Jaccard distance

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_weighted\_distance\_by\_id() (tmap.LSHForest method)@\spxentry{get\_weighted\_distance\_by\_id()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.get_weighted_distance_by_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_weighted\_distance\_by\_id}}}{\emph{self: tmap.LSHForest}, \emph{arg0: int}, \emph{arg1: int}}{{ $\rightarrow$ float}}
Calculate the Jaccard distance between two indexed weighted MinHash vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The id of an indexed weighted MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The id of an indexed weighted MinHash vector

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{float}} The weighted Jaccard distance

\end{description}\end{quote}

\end{fulllineitems}

\index{index() (tmap.LSHForest method)@\spxentry{index()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.index}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{index}}}{\emph{self: tmap.LSHForest}}{{ $\rightarrow$ None}}
Index the LSH forest. This has to be run after each time new MinHashes were added.

\end{fulllineitems}

\index{is\_clean() (tmap.LSHForest method)@\spxentry{is\_clean()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.is_clean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_clean}}}{\emph{self: tmap.LSHForest}}{{ $\rightarrow$ bool}}
Returns a boolean indicating whether or not the LSH forest has been indexed after the last MinHash vector was added.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{True}} if {\hyperref[\detokenize{documentation:tmap.LSHForest.index}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{index()}}}}} has been run since MinHash vectors have last been added using {\hyperref[\detokenize{documentation:tmap.LSHForest.add}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add()}}}}} or {\hyperref[\detokenize{documentation:tmap.LSHForest.batch_add}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{batch\_add()}}}}}. \sphinxcode{\sphinxupquote{False}} otherwise

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{bool}}

\end{description}\end{quote}

\end{fulllineitems}

\index{linear\_scan() (tmap.LSHForest method)@\spxentry{linear\_scan()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.linear_scan}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linear\_scan}}}{\emph{self: tmap.LSHForest}, \emph{vec: tmap.VectorUint}, \emph{indices: tmap.VectorUint}, \emph{k: int=10}, \emph{weighted: bool=False}}{{ $\rightarrow$ List{[}Tuple{[}float, int{]}{]}}}
Query a subset of indexed MinHash vectors using linear scan.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} The query MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{indices}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} 

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weighted}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} Whether the MinHash vectors in this {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance are weighted

\end{itemize}

\item[{Returns}] \leavevmode
The results of the query

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{Tuple{[}float, int{]}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{query() (tmap.LSHForest method)@\spxentry{query()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.query}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query}}}{\emph{self: tmap.LSHForest}, \emph{arg0: tmap.VectorUint}, \emph{arg1: int}}{{ $\rightarrow$ tmap.VectorUint}}
Query the LSH forest for k-nearest neighbors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} The query MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\end{itemize}

\item[{Returns}] \leavevmode
The results of the query

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{query\_by\_id() (tmap.LSHForest method)@\spxentry{query\_by\_id()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.query_by_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query\_by\_id}}}{\emph{self: tmap.LSHForest}, \emph{arg0: int}, \emph{arg1: int}}{{ $\rightarrow$ tmap.VectorUint}}
Query the LSH forest for k-nearest neighbors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The id of an indexed MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\end{itemize}

\item[{Returns}] \leavevmode
The results of the query

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{query\_exclude() (tmap.LSHForest method)@\spxentry{query\_exclude()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.query_exclude}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query\_exclude}}}{\emph{self: tmap.LSHForest}, \emph{arg0: tmap.VectorUint}, \emph{arg1: tmap.VectorUint}, \emph{arg2: int}}{{ $\rightarrow$ tmap.VectorUint}}
Query the LSH forest for k-nearest neighbors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} The query MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{exclude}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\end{itemize}

\item[{Returns}] \leavevmode
The results of the query

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{query\_exclude\_by\_id() (tmap.LSHForest method)@\spxentry{query\_exclude\_by\_id()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.query_exclude_by_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query\_exclude\_by\_id}}}{\emph{self: tmap.LSHForest}, \emph{arg0: int}, \emph{arg1: tmap.VectorUint}, \emph{arg2: int}}{{ $\rightarrow$ tmap.VectorUint}}
Query the LSH forest for k-nearest neighbors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The id of an indexed MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{exclude}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\end{itemize}

\item[{Returns}] \leavevmode
The results of the query

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{query\_linear\_scan() (tmap.LSHForest method)@\spxentry{query\_linear\_scan()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.query_linear_scan}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query\_linear\_scan}}}{\emph{self: tmap.LSHForest}, \emph{vec: tmap.VectorUint}, \emph{k: int}, \emph{kc: int=10}, \emph{weighted: bool=False}}{{ $\rightarrow$ List{[}Tuple{[}float, int{]}{]}}}
Query k-nearest neighbors with a LSH forest / linear scan combination. \sphinxcode{\sphinxupquote{k{}`*:obj:{}`kc}} nearest neighbors are searched for using LSH forest; from these, the \sphinxcode{\sphinxupquote{k}} nearest neighbors are retrieved using linear scan.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} The query MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kc}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The factor by which \sphinxcode{\sphinxupquote{k}} is multiplied for LSH forest retreival

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weighted}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} Whether the MinHash vectors in this {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance are weighted

\end{itemize}

\item[{Returns}] \leavevmode
The results of the query

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{Tuple{[}float, int{]}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{query\_linear\_scan\_by\_id() (tmap.LSHForest method)@\spxentry{query\_linear\_scan\_by\_id()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.query_linear_scan_by_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query\_linear\_scan\_by\_id}}}{\emph{self: tmap.LSHForest}, \emph{id: int}, \emph{k: int}, \emph{kc: int=10}, \emph{weighted: bool=False}}{{ $\rightarrow$ List{[}Tuple{[}float, int{]}{]}}}
Query k-nearest neighbors with a LSH forest / linear scan combination. \sphinxcode{\sphinxupquote{k{}`*:obj:{}`kc}} nearest neighbors are searched for using LSH forest; from these, the \sphinxcode{\sphinxupquote{k}} nearest neighbors are retrieved using linear scan.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The id of an indexed MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kc}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The factor by which \sphinxcode{\sphinxupquote{k}} is multiplied for LSH forest retreival

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weighted}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} Whether the MinHash vectors in this {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance are weighted

\end{itemize}

\item[{Returns}] \leavevmode
The results of the query

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{Tuple{[}float, int{]}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{query\_linear\_scan\_exclude() (tmap.LSHForest method)@\spxentry{query\_linear\_scan\_exclude()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.query_linear_scan_exclude}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query\_linear\_scan\_exclude}}}{\emph{self: tmap.LSHForest}, \emph{vec: tmap.VectorUint}, \emph{k: int}, \emph{exclude: tmap.VectorUint}, \emph{kc: int=10}, \emph{weighted: bool=False}}{{ $\rightarrow$ List{[}Tuple{[}float, int{]}{]}}}
Query k-nearest neighbors with a LSH forest / linear scan combination. \sphinxcode{\sphinxupquote{k{}`*:obj:{}`kc}} nearest neighbors are searched for using LSH forest; from these, the \sphinxcode{\sphinxupquote{k}} nearest neighbors are retrieved using linear scan.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} The query MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{exclude}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kc}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The factor by which \sphinxcode{\sphinxupquote{k}} is multiplied for LSH forest retreival

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weighted}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} Whether the MinHash vectors in this {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance are weighted

\end{itemize}

\item[{Returns}] \leavevmode
The results of the query

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{Tuple{[}float, int{]}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{query\_linear\_scan\_exclude\_by\_id() (tmap.LSHForest method)@\spxentry{query\_linear\_scan\_exclude\_by\_id()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.query_linear_scan_exclude_by_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{query\_linear\_scan\_exclude\_by\_id}}}{\emph{self: tmap.LSHForest}, \emph{id: int}, \emph{k: int}, \emph{exclude: tmap.VectorUint}, \emph{kc: int=10}, \emph{weighted: bool=False}}{{ $\rightarrow$ List{[}Tuple{[}float, int{]}{]}}}
Query k-nearest neighbors with a LSH forest / linear scan combination. \sphinxcode{\sphinxupquote{k{}`*:obj:{}`kc}} nearest neighbors are searched for using LSH forest; from these, the \sphinxcode{\sphinxupquote{k}} nearest neighbors are retrieved using linear scan.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The id of an indexed MinHash vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors to be retrieved

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{exclude}} (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kc}} (\sphinxcode{\sphinxupquote{int}}) \textendash{} The factor by which \sphinxcode{\sphinxupquote{k}} is multiplied for LSH forest retreival

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weighted}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} Whether the MinHash vectors in this {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance are weighted

\end{itemize}

\item[{Returns}] \leavevmode
The results of the query

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{Tuple{[}float, int{]}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{restore() (tmap.LSHForest method)@\spxentry{restore()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.restore}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{restore}}}{\emph{self: tmap.LSHForest}, \emph{arg0: str}}{{ $\rightarrow$ None}}
Deserializes a previously serialized (using {\hyperref[\detokenize{documentation:tmap.LSHForest.store}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{store()}}}}}) state into this instance of {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} and recreates the index.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxcode{\sphinxupquote{str}}) \textendash{} The path to the file which is deserialized

\end{description}\end{quote}

\end{fulllineitems}

\index{size() (tmap.LSHForest method)@\spxentry{size()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{size}}}{\emph{self: tmap.LSHForest}}{{ $\rightarrow$ int}}
Returns the number of MinHash vectors in this LSHForest instance.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The number of MinHash vectors

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}

\index{store() (tmap.LSHForest method)@\spxentry{store()}\spxextra{tmap.LSHForest method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LSHForest.store}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{store}}}{\emph{self: tmap.LSHForest}, \emph{arg0: str}}{{ $\rightarrow$ None}}
Serializes the current state of this instance of {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} to the disk in binary format. The index is not serialized and has to be rebuilt after deserialization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxcode{\sphinxupquote{str}}) \textendash{} The path to which to searialize the file

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Layout}
\label{\detokenize{documentation:layout}}\label{\detokenize{documentation:layout-doc}}\index{layout\_from\_lsh\_forest() (in module tmap)@\spxentry{layout\_from\_lsh\_forest()}\spxextra{in module tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.layout_from_lsh_forest}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{layout\_from\_lsh\_forest}}}{}{}
layout\_from\_lsh\_forest(lsh\_forest: tmap::LSHForest, config: tmap.LayoutConfiguration=k: 10
kc: 10
fme\_iterations: 1000
fme\_randomize: 0
fme\_threads: 4
fme\_precision: 4
sl\_repeats: 1
sl\_extra\_scaling\_steps: 1
sl\_scaling\_x: 5.000000
sl\_scaling\_y: 20.000000
sl\_scaling\_type: RelativeToDrawing
mmm\_repeats: 1
placer: Barycenter
merger: LocalBiconnected
merger\_factor: 2.000000
merger\_adjustment: 0
node\_size1.000000, create\_mst: bool=True, clear\_lsh\_forest: bool=False, weighted: bool=False) -\textgreater{} Tuple{[}tmap.VectorFloat, tmap.VectorFloat, tmap.VectorUint, tmap.VectorUint, tmap.GraphProperties{]}
\begin{quote}

Create minimum spanning tree or k-nearest neighbor graph coordinates and topology from an {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance.
\begin{description}
\item[{Arguments:}] \leavevmode
lsh\_forest ({\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}}): An {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance

\item[{Keyword Arguments:}] \leavevmode
config ({\hyperref[\detokenize{documentation:tmap.LayoutConfiguration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LayoutConfiguration}}}}}, optional): An {\hyperref[\detokenize{documentation:tmap.LayoutConfiguration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LayoutConfiguration}}}}} instance
create\_mst (\sphinxcode{\sphinxupquote{bool}}): Whether to create a minimum spanning tree or to return coordinates and topology for the k-nearest neighbor graph
clear\_lsh\_forest (\sphinxcode{\sphinxupquote{bool}}): Whether to run \sphinxcode{\sphinxupquote{clear()}} on the {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance after k-nearest negihbor graph and MST creation and before layout
weighted (\sphinxcode{\sphinxupquote{bool}}): Whether the MinHash vectors in the {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance are weighted

\item[{Returns:}] \leavevmode
\sphinxcode{\sphinxupquote{Tuple{[}VectorFloat, VectorFloat, VectorUint, VectorUint, GraphProperties{]}}} The x and y coordinates of the vertices, the ids of the vertices spanning the edges, and information on the graph

\end{description}
\end{quote}

\end{fulllineitems}

\index{layout\_from\_edge\_list() (in module tmap)@\spxentry{layout\_from\_edge\_list()}\spxextra{in module tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.layout_from_edge_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{layout\_from\_edge\_list}}}{}{}
layout\_from\_edge\_list(vertex\_count: int, edges: List{[}Tuple{[}int, int, float{]}{]}, config: tmap.LayoutConfiguration=k: 10
kc: 10
fme\_iterations: 1000
fme\_randomize: 0
fme\_threads: 4
fme\_precision: 4
sl\_repeats: 1
sl\_extra\_scaling\_steps: 1
sl\_scaling\_x: 5.000000
sl\_scaling\_y: 20.000000
sl\_scaling\_type: RelativeToDrawing
mmm\_repeats: 1
placer: Barycenter
merger: LocalBiconnected
merger\_factor: 2.000000
merger\_adjustment: 0
node\_size1.000000, create\_mst: bool=True) -\textgreater{} Tuple{[}tmap.VectorFloat, tmap.VectorFloat, tmap.VectorUint, tmap.VectorUint, tmap.GraphProperties{]}
\begin{quote}

Create minimum spanning tree or k-nearest neighbor graph coordinates and topology from an edge list.
\begin{description}
\item[{Arguments:}] \leavevmode
vertex\_count (\sphinxcode{\sphinxupquote{int}}): The number of vertices in the edge list
edges (\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{Tuple{[}int, int, float{]}}}): An edge list defining a graph

\item[{Keyword Arguments:}] \leavevmode
config ({\hyperref[\detokenize{documentation:tmap.LayoutConfiguration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LayoutConfiguration}}}}}, optional): An {\hyperref[\detokenize{documentation:tmap.LayoutConfiguration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LayoutConfiguration}}}}} instance
create\_mst (\sphinxcode{\sphinxupquote{bool}}): Whether to create a minimum spanning tree or to return coordinates and topology for the k-nearest neighbor graph

\item[{Returns:}] \leavevmode
\sphinxcode{\sphinxupquote{Tuple{[}VectorFloat, VectorFloat, VectorUint, VectorUint, GraphProperties{]}}}: The x and y coordinates of the vertices, the ids of the vertices spanning the edges, and information on the graph

\end{description}
\end{quote}

\end{fulllineitems}

\index{mst\_from\_lsh\_forest() (in module tmap)@\spxentry{mst\_from\_lsh\_forest()}\spxextra{in module tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.mst_from_lsh_forest}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{mst\_from\_lsh\_forest}}}{\emph{lsh\_forest: tmap::LSHForest}, \emph{k: int}, \emph{kc: int=10}, \emph{weighted: bool=False}}{{ $\rightarrow$ Tuple{[}tmap.VectorUint, tmap.VectorUint{]}}}
Create minimum spanning tree topology from an {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lsh\_forest}} ({\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}}) \textendash{} An {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of nearest neighbors used to create the k-nearest neighbor graph

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kc}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The scalar by which k is multiplied before querying the LSH forest. The results are then ordered decreasing based on linear-scan distances and the top k results returned

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weighted}} (\sphinxcode{\sphinxupquote{bool}}) \textendash{} Whether the MinHash vectors in the {\hyperref[\detokenize{documentation:tmap.LSHForest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LSHForest}}}}} instance are weighted

\end{itemize}

\item[{Returns}] \leavevmode
the topology of the minimum spanning tree of the data indexed in the LSH forest

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{Tuple{[}VectorUint, VectorUint{]}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{ScalingType (class in tmap)@\spxentry{ScalingType}\spxextra{class in tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.ScalingType}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{ScalingType}}}{\emph{self: tmap.ScalingType}, \emph{arg0: int}}{{ $\rightarrow$ None}}
The scaling types available in OGDF. The class is to be used as an enum.
\subsubsection*{Notes}

The available values are

\sphinxcode{\sphinxupquote{ScalingType.Absolute}}: Absolute factor, can be used to scale relative to level size change.

\sphinxcode{\sphinxupquote{ScalingType.RelativeToAvgLength}}: Scales by a factor relative to the average edge weights.

\sphinxcode{\sphinxupquote{ScalingType.RelativeToDesiredLength}}: Scales by a factor relative to the disired edge length.

\sphinxcode{\sphinxupquote{ScalingType.RelativeToDrawing}}: Scales by a factor relative to the drawing.

\end{fulllineitems}

\index{Placer (class in tmap)@\spxentry{Placer}\spxextra{class in tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Placer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{Placer}}}{\emph{self: tmap.Placer}, \emph{arg0: int}}{{ $\rightarrow$ None}}
The places available in OGDF. The class is to be used as an enum.
\subsubsection*{Notes}

The available values are

\sphinxcode{\sphinxupquote{Placer.Barycenter}}: Places a vertex at the barycenter of its neighbors’ position.

\sphinxcode{\sphinxupquote{Placer.Solar}}: Uses information of the merging phase of the solar merger. Places a new vertex on the direct line between two suns.

\sphinxcode{\sphinxupquote{Placer.Circle}}: Places the vertices in a circle around the barycenter and outside of the current drawing

\sphinxcode{\sphinxupquote{Placer.Median}}: Places a vertex at the median position of the neighbor nodes for each coordinate axis.

\sphinxcode{\sphinxupquote{Placer.Random}}: Places a vertex at a random position within the smallest circle containing all vertices around the barycenter of the current drawing.

\sphinxcode{\sphinxupquote{Placer.Zero}}: Places a vertex at the same position as its representative in the previous level.

\end{fulllineitems}

\index{Merger (class in tmap)@\spxentry{Merger}\spxextra{class in tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.Merger}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{Merger}}}{\emph{self: tmap.Merger}, \emph{arg0: int}}{{ $\rightarrow$ None}}
The mergers available in OGDF. The class is to be used as an enum.
\subsubsection*{Notes}

The available values are

\sphinxcode{\sphinxupquote{Merger.EdgeCover}}: Based on the matching merger. Computes an edge cover such that each contained edge is incident to at least one unmatched vertex. The cover edges are then used to merge their adjacent vertices.

\sphinxcode{\sphinxupquote{Merger.LocalBiconnected}}: Based on the edge cover merger. Avoids distortions by checking whether biconnectivity will be lost in the local neighborhood around the potential merging position.

\sphinxcode{\sphinxupquote{Merger.Solar}}: Vertices are partitioned into solar systems, consisting of sun, planets and moons. The systems are then merged into the sun vertices.

\sphinxcode{\sphinxupquote{Merger.IndependentSet}}: Uses a maximal independent set filtration. See GRIP for details.

\end{fulllineitems}

\index{LayoutConfiguration (class in tmap)@\spxentry{LayoutConfiguration}\spxextra{class in tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LayoutConfiguration}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{LayoutConfiguration}}}{\emph{self: tmap.LayoutConfiguration}}{{ $\rightarrow$ None}}
A container for configuration options for {\hyperref[\detokenize{documentation:tmap.layout_from_lsh_forest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{layout\_from\_lsh\_forest()}}}}} and {\hyperref[\detokenize{documentation:tmap.layout_from_edge_list}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{layout\_from\_edge\_list()}}}}}.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{int~k}}}
The number of nearest neighbors used to create the k-nearest neighbor graph.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{int~kc}}}
The scalar by which k is multiplied before querying the LSH forest. The results are then ordered decreasing based on linear-scan distances and the top k results returned.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{int~fme\_iterations}}}
Maximum number of iterations of the fast multipole embedder.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{bool~fme\_randomize}}}
Whether or not to randomize the layout at the start.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{bool}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{int~fme\_threads}}}
The number of threads for the fast multipole embedder.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{int~fme\_precision}}}
The number of coefficients of the multipole expansion.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{int~sl\_repeats}}}
The number of repeats of the scaling layout algorithm.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{int~sl\_extra\_scaling\_steps}}}
Sets the number of repeats of the scaling.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{double~sl\_scaling\_min}}}
The minimum scaling factor.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{float}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{double~sl\_scaling\_max}}}
The maximum scaling factor.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{float}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{ScalingType~sl\_scaling\_type}}}
Defines the (relative) scale of the graph.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{documentation:tmap.ScalingType}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ScalingType}}}}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{int~mmm\_repeats}}}
Number of repeats of the per-level layout algorithm.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{Placer~placer}}}
The  method  by  which  the  initial  positons  of  the  vertices  at  eachlevel are defined.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{documentation:tmap.Placer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Placer}}}}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{Merger~merger}}}
The vertex merging strategy applied during the coarsening phaseof the multilevel algorithm.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{documentation:tmap.Merger}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Merger}}}}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{double~merger\_factor}}}
The ratio of the sizes between two levels up to which the mergingis run.  Does not apply to all merging strategies.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{float}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{int~merger\_adjustment}}}
The  edge  length  adjustment  of  the  merging  algorithm.   Does  notapply to all merging strategies.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{float~node\_size}}}
The size of the nodes, which affects the magnitude of their repellingforce. Decreasing  this  value  generally  resolves  overlaps  in  a  verycrowded tree.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{float}}

\end{description}\end{quote}

\end{fulllineitems}


Constructor for the class {\hyperref[\detokenize{documentation:tmap.LayoutConfiguration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LayoutConfiguration}}}}}.
\index{\_\_init\_\_() (tmap.LayoutConfiguration method)@\spxentry{\_\_init\_\_()}\spxextra{tmap.LayoutConfiguration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.LayoutConfiguration.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{self: tmap.LayoutConfiguration}}{{ $\rightarrow$ None}}
Constructor for the class {\hyperref[\detokenize{documentation:tmap.LayoutConfiguration}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LayoutConfiguration}}}}}.

\end{fulllineitems}


\end{fulllineitems}

\index{GraphProperties (class in tmap)@\spxentry{GraphProperties}\spxextra{class in tmap}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.GraphProperties}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{tmap.}}\sphinxbfcode{\sphinxupquote{GraphProperties}}}{\emph{self: tmap.GraphProperties}}{{ $\rightarrow$ None}}
Contains properties of the minimum spanning tree (or forest) generated by {\hyperref[\detokenize{documentation:tmap.layout_from_lsh_forest}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{layout\_from\_lsh\_forest()}}}}} and {\hyperref[\detokenize{documentation:tmap.layout_from_edge_list}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{layout\_from\_edge\_list()}}}}}.
\index{mst\_weight (tmap.GraphProperties attribute)@\spxentry{mst\_weight}\spxextra{tmap.GraphProperties attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.GraphProperties.mst_weight}}\pysigline{\sphinxbfcode{\sphinxupquote{mst\_weight}}}
The total weight of the minimum spanning tree.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{float}}

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_connected\_components (tmap.GraphProperties attribute)@\spxentry{n\_connected\_components}\spxextra{tmap.GraphProperties attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.GraphProperties.n_connected_components}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_connected\_components}}}
The number of connected components in the minimum spanning forest.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_isolated\_vertices (tmap.GraphProperties attribute)@\spxentry{n\_isolated\_vertices}\spxextra{tmap.GraphProperties attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.GraphProperties.n_isolated_vertices}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_isolated\_vertices}}}~\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{int}}

\end{description}\end{quote}

\end{fulllineitems}

\index{degrees (tmap.GraphProperties attribute)@\spxentry{degrees}\spxextra{tmap.GraphProperties attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.GraphProperties.degrees}}\pysigline{\sphinxbfcode{\sphinxupquote{degrees}}}
The degrees of all vertices in the minimum spanning tree (or forest).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}

\index{adjacency\_list (tmap.GraphProperties attribute)@\spxentry{adjacency\_list}\spxextra{tmap.GraphProperties attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.GraphProperties.adjacency_list}}\pysigline{\sphinxbfcode{\sphinxupquote{adjacency\_list}}}
The adjaceny lists for all vertices in the minimum spanning tree (or forest).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{List}} of \sphinxcode{\sphinxupquote{VectorUint}}

\end{description}\end{quote}

\end{fulllineitems}


Constructor for the class {\hyperref[\detokenize{documentation:tmap.GraphProperties}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GraphProperties}}}}}.
\index{\_\_init\_\_() (tmap.GraphProperties method)@\spxentry{\_\_init\_\_()}\spxextra{tmap.GraphProperties method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{documentation:tmap.GraphProperties.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{self: tmap.GraphProperties}}{{ $\rightarrow$ None}}
Constructor for the class {\hyperref[\detokenize{documentation:tmap.GraphProperties}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GraphProperties}}}}}.

\end{fulllineitems}


\end{fulllineitems}




\renewcommand{\indexname}{Index}
\printindex
\end{document}